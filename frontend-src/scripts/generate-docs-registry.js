#!/usr/bin/env node

const fs = require('fs');
const path = require('path');

const DOCS_DIR = path.join(__dirname, '../assets/docs');
const REGISTRY_OUTPUT_FILE = path.join(__dirname, '../components/docs/constants/docRegistry.generated.ts');
const CATEGORIES_OUTPUT_FILE = path.join(__dirname, '../components/docs/constants/docCategories.generated.ts');

// Default category metadata - can be overridden by specific folder structure
const DEFAULT_CATEGORY_CONFIG = {
    'general': { icon: 'ðŸ“š', name: 'General', order: 0 },
    'about': { icon: 'ðŸ“‹', name: 'About', order: 10 },
    'workflows': { icon: 'âš¡', name: 'Workflows', order: 20 },
    'credits': { icon: 'ðŸ‘¥', name: 'Credits', order: 30 },
    'policies': { icon: 'âš–ï¸', name: 'Policies & Ethics', order: 40 },
    'design': { icon: 'ðŸŽ¨', name: 'Design System', order: 50 },
    'technical': { icon: 'ðŸ”§', name: 'Technical Docs', order: 60 },
    'api': { icon: 'ðŸ”Œ', name: 'API Reference', order: 70 },
};

function scanDirectoryStructure(dir, baseDir = dir, currentPath = '') {
    const categories = new Set();
    const items = [];

    if (!fs.existsSync(dir)) {
        return { categories, items };
    }

    const entries = fs.readdirSync(dir, { withFileTypes: true });

    for (const entry of entries) {
        const fullPath = path.join(dir, entry.name);
        const relativePath = path.relative(baseDir, fullPath);
        const entryPath = currentPath ? `${currentPath}/${entry.name}` : entry.name;

        if (entry.isDirectory()) {
            // Add this directory as a category
            categories.add(entryPath);

            // Recursively scan subdirectory
            const subResult = scanDirectoryStructure(fullPath, baseDir, entryPath);
            subResult.categories.forEach(cat => categories.add(cat));
            items.push(...subResult.items);
        } else if (entry.isFile() && entry.name.endsWith('.md')) {
            const slug = relativePath
                .replace(/\.md$/, '')
                .replace(/\\/g, '/') // Normalize path separators
                .replace(/\/index$/, '') // Convert 'workflows/index' to 'workflows'
                .replace(/^index$/, 'home'); // Convert root 'index' to 'home'

            // Determine category from path structure
            const pathParts = relativePath.split(/[\/\\]/);
            let category;

            if (pathParts.length > 1) {
                // Use the top-level folder as category
                category = pathParts[0];
            } else {
                // Root-level files go to 'general'
                category = 'general';
            }

            // Also track nested categories for more complex structures
            const nestedCategory = currentPath || category;

            categories.add(category);
            if (nestedCategory !== category) {
                categories.add(nestedCategory);
            }

            items.push({
                slug,
                filePath: relativePath.replace(/\\/g, '/'),
                category,
                nestedCategory: nestedCategory !== category ? nestedCategory : undefined,
                requirePath: `@/assets/docs/${relativePath.replace(/\\/g, '/')}`
            });
        }
    }

    return { categories, items };
}

function generateCategoryConfig(categories) {
    const categoryArray = Array.from(categories).filter(cat => cat !== 'general');

    // Always include 'general' at the beginning
    const allCategories = ['general', ...categoryArray.sort()];

    const categoryIcons = {};
    const categoryNames = {};

    allCategories.forEach(cat => {
        const config = DEFAULT_CATEGORY_CONFIG[cat];
        if (config) {
            categoryIcons[cat] = config.icon;
            categoryNames[cat] = config.name;
        } else {
            // Generate default icon and name for new categories
            categoryIcons[cat] = 'ðŸ“„';
            categoryNames[cat] = cat.split('/').pop()
                .split('-')
                .map(word => word.charAt(0).toUpperCase() + word.slice(1))
                .join(' ');
        }
    });

    return {
        order: allCategories,
        icons: categoryIcons,
        names: categoryNames
    };
}

function generateCategoriesFile(categoryConfig) {
    const orderArray = categoryConfig.order.map(cat => `'${cat}'`).join(', ');

    const iconsEntries = Object.entries(categoryConfig.icons)
        .map(([key, value]) => `    '${key}': '${value}'`)
        .join(',\n');

    const namesEntries = Object.entries(categoryConfig.names)
        .map(([key, value]) => `    '${key}': '${value}'`)
        .join(',\n');

    const categoriesContent = `// Auto-generated category configuration
// This file is generated by scripts/generate-docs-registry.js during prebuild

export const CATEGORY_ORDER = [${orderArray}] as const;

export const CATEGORY_ICONS: Record<string, string> = {
${iconsEntries}
} as const;

export const CATEGORY_NAMES: Record<string, string> = {
${namesEntries}
} as const;

export const PREFERRED_DEFAULT_DOCS = ['home', 'index', 'getting-started', 'ethics'] as const;

export type DocCategory = typeof CATEGORY_ORDER[number];
`;

    return categoriesContent;
}

function generateRegistryFile(docs) {
    // Generate TypeScript imports and registry
    const imports = docs.map(doc =>
        `import ${doc.slug.replace(/[^a-zA-Z0-9]/g, '_')} from '${doc.requirePath}';`
    ).join('\n');

    const moduleEntries = docs.map(doc =>
        `  '${doc.slug}': ${doc.slug.replace(/[^a-zA-Z0-9]/g, '_')}`
    ).join(',\n');

    const metadataEntries = docs.map(doc => {
        const base = `    slug: '${doc.slug}',
    filePath: '${doc.filePath}',
    category: '${doc.category}'`;

        const nested = doc.nestedCategory ? `,
    nestedCategory: '${doc.nestedCategory}'` : '';

        return `  {\n${base}${nested}\n  }`;
    }).join(',\n');

    const registryContent = `// Auto-generated docs registry
// This file is generated by scripts/generate-docs-registry.js during prebuild
// Categories are defined in ../components/docs/constants/docCategories.generated.ts

import type { DocCategory } from '@/components/docs/constants/docCategories.generated';

${imports}

export const docsModules = {
${moduleEntries}
};

export const docsMetadata = [
${metadataEntries}
];

export type DocMetadata = {
  slug: string;
  filePath: string;
  category: DocCategory;
  nestedCategory?: string;
};
`;

    return registryContent;
}

function generateRegistry() {
    if (!fs.existsSync(DOCS_DIR)) {
        console.warn('Docs directory not found, creating empty registry');

        const emptyRegistry = `// Auto-generated docs registry
export const docsModules = {};
export const docsMetadata = [];
`;

        const emptyCategories = `// Auto-generated category configuration
export const CATEGORY_ORDER = ['general'] as const;
export const CATEGORY_ICONS = { 'general': 'ðŸ“š' } as const;
export const CATEGORY_NAMES = { 'general': 'General' } as const;
export const PREFERRED_DEFAULT_DOCS = ['home'] as const;
`;

        // Ensure directories exist
        [REGISTRY_OUTPUT_FILE, CATEGORIES_OUTPUT_FILE].forEach(file => {
            const dir = path.dirname(file);
            if (!fs.existsSync(dir)) {
                fs.mkdirSync(dir, { recursive: true });
            }
        });

        fs.writeFileSync(REGISTRY_OUTPUT_FILE, emptyRegistry);
        fs.writeFileSync(CATEGORIES_OUTPUT_FILE, emptyCategories);
        return;
    }

    const { categories, items: docs } = scanDirectoryStructure(DOCS_DIR);
    const categoryConfig = generateCategoryConfig(categories);

    // Generate both files
    const registryContent = generateRegistryFile(docs);
    const categoriesContent = generateCategoriesFile(categoryConfig);

    // Ensure directories exist
    [REGISTRY_OUTPUT_FILE, CATEGORIES_OUTPUT_FILE].forEach(file => {
        const dir = path.dirname(file);
        if (!fs.existsSync(dir)) {
            fs.mkdirSync(dir, { recursive: true });
        }
    });

    fs.writeFileSync(REGISTRY_OUTPUT_FILE, registryContent);
    fs.writeFileSync(CATEGORIES_OUTPUT_FILE, categoriesContent);

    console.log(`Generated docs registry with ${docs.length} documents:`);
    docs.forEach(doc => {
        const nested = doc.nestedCategory ? ` -> ${doc.nestedCategory}` : '';
        console.log(`  - ${doc.slug} (${doc.category}${nested})`);
    });

    console.log(`\nGenerated categories: ${Array.from(categories).join(', ')}`);
}

// Create directories if they don't exist
const srcDir = path.join(__dirname, '../src');
const constantsDir = path.join(__dirname, '../components/docs/constants');

[srcDir, constantsDir].forEach(dir => {
    if (!fs.existsSync(dir)) {
        fs.mkdirSync(dir, { recursive: true });
    }
});

generateRegistry();